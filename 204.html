<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>일차함수 그래프 맞추기</title>
<script>window.MathJax = { tex: { inlineMath: [['$', '$']] } };</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" async></script>
<style>
  body { 
    font-family: sans-serif; 
    text-align: center; 
    margin: 0;
    padding: 10px;
    background-color: #f9f9f9;
  }
  .container { 
    max-width: 600px; 
    margin: 0 auto; 
    background: white; 
    padding: 20px; 
    border-radius: 15px; 
    box-shadow: 0 4px 10px rgba(0,0,0,0.1); 
  }

  /* 그래프 영역 */
  canvas { 
    border: 2px solid #333; 
    background: #fff; 
    margin-top: 10px;
    max-width: 100%;
    height: auto;
  }

  /* 컨트롤 영역 */
  .control-panel {
    margin-top: 20px;
    padding: 20px;
    background: #eee;
    border-radius: 10px;
    text-align: left;
  }
  
  .slider-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
    font-size: 18px;
  }
  
  input[type=range] { 
    flex-grow: 1; 
    margin: 0 15px; 
    cursor: pointer;
  }
  
  .value-display {
    font-weight: bold;
    width: 40px;
    text-align: right;
    color: #333;
  }

  /* 버튼 스타일 */
  .check-btn {
    width: 100%;
    padding: 15px;
    font-size: 20px;
    background-color: #3399FF;
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    margin-top: 10px;
    transition: background 0.2s;
  }
  .check-btn:hover { background-color: #2b80d6; }

  /* 점수판 스타일 */
  #result1, #result2, #result3 {
    font-size: 24px;
    margin: 10px 0;
    padding: 10px;
    border-radius: 5px;
  }
  #result1 { min-height: 30px; }
  
  .eq-display {
    font-size: 22px;
    margin: 5px 0;
  }
  .target-color { color: blue; font-weight: bold; }
  .user-color { color: red; font-weight: bold; }
  
  hr { margin: 20px 0; border: 0; border-top: 1px solid #ddd; }
</style>
</head>
<body>

<div class="container">
  <h1>일차함수 그래프 맞추기</h1>
  <p>파란색 목표 그래프와 똑같이 빨간색 그래프를 만드세요!</p>

  <!-- 수식 표시 영역 -->
  <div style="margin-bottom: 10px;">
    <div class="eq-display target-color">목표: <span id="targetEq">$y = ?$</span></div>
    <div class="eq-display user-color">현재: <span id="currentEq">$y = x$</span></div>
  </div>

  <!-- 캔버스 (그래프) -->
  <canvas id="graphCanvas" width="400" height="400"></canvas>

  <!-- 컨트롤 패널 -->
  <div class="control-panel">
    <div class="slider-row">
      <label>기울기 ($a$)</label>
      <input type="range" id="sliderA" min="-5" max="5" step="0.5" value="1" oninput="updateGraph()">
      <span id="valA" class="value-display">1</span>
    </div>
    
    <div class="slider-row">
      <label>$y$절편 ($b$)</label>
      <input type="range" id="sliderB" min="-5" max="5" step="1" value="0" oninput="updateGraph()">
      <span id="valB" class="value-display">0</span>
    </div>
    
    <button class="check-btn" onclick="checkMatch()">정답 확인</button>
  </div>

  <hr/>

  <!-- 결과 및 점수 표시 -->
  <div id="result1">정답여부</div>
  <div id="result2">0번 정답입니다.</div>
  <div id="result3">0번 틀렸습니다.</div>
</div>

<script>
// 전역 변수
let targetA, targetB;
let wincount = 0;
let losecount = 0;
let isProcessing = false;

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
const w = canvas.width;
const h = canvas.height;
const scale = 40; // 1 unit = 40px

// 캔버스 좌표 변환
function toCanvasX(x) { return w/2 + x * scale; }
function toCanvasY(y) { return h/2 - y * scale; }

// 수식 포맷팅 함수
function formatEquation(a, b) {
  let str = "";

  // 기울기 처리
  if (a === 0) {
    // 0이면 생략 (하지만 문제 출제시 0은 제외됨)
  } else if (a === 1) {
    str += "x";
  } else if (a === -1) {
    str += "-x";
  } else {
    str += a + "x";
  }

  // y절편 처리
  if (b === 0) {
    if (str === "") str = "0"; 
  } else if (b > 0) {
    if (str !== "") str += " + " + b;
    else str += b;
  } else { // b < 0
    if (str !== "") str += " - " + Math.abs(b);
    else str += "-" + Math.abs(b);
  }

  return "y = " + str;
}

// 화살표 그리기 함수
function drawArrow(fromX, fromY, toX, toY) {
    const headlen = 10;
    const dx = toX - fromX;
    const dy = toY - fromY;
    const angle = Math.atan2(dy, dx);
    
    ctx.beginPath();
    ctx.moveTo(fromX, fromY);
    ctx.lineTo(toX, toY);
    ctx.stroke();
    
    ctx.beginPath();
    ctx.moveTo(toX, toY);
    ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(toX, toY);
    ctx.fillStyle = "black";
    ctx.fill();
}

// 그리드 및 축 그리기
function drawGrid() {
  ctx.clearRect(0, 0, w, h);
  
  // 모눈종이
  ctx.strokeStyle = "#e0e0e0";
  ctx.lineWidth = 1;
  for(let i=0; i<=w; i+=scale) {
    ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(w,i); ctx.stroke();
  }
  
  // 축 (Axes)
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2;
  
  drawArrow(0, h/2, w, h/2); // X축
  drawArrow(w/2, h, w/2, 0); // Y축
  
  // 라벨
  ctx.font = "italic bold 18px Times New Roman";
  ctx.fillStyle = "black";
  
  ctx.textAlign = "right";
  ctx.fillText("x", w - 10, h/2 + 20); // x
  
  ctx.textAlign = "left";
  ctx.fillText("y", w/2 + 10, 20); // y
  
  ctx.font = "italic 16px Times New Roman";
  ctx.textAlign = "right";
  ctx.fillText("O", w/2 - 5, h/2 + 20); // O
}

// 직선 그리기
function drawLine(a, b, color, width) {
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  
  let x1 = -10; let y1 = a*x1 + b;
  let x2 = 10; let y2 = a*x2 + b;
  
  ctx.moveTo(toCanvasX(x1), toCanvasY(y1));
  ctx.lineTo(toCanvasX(x2), toCanvasY(y2));
  ctx.stroke();
}

// 그래프 업데이트
function updateGraph() {
  let userA = parseFloat(document.getElementById('sliderA').value);
  let userB = parseFloat(document.getElementById('sliderB').value);
  
  document.getElementById('valA').innerText = userA;
  document.getElementById('valB').innerText = userB;
  
  let eq = formatEquation(userA, userB);
  const eqDiv = document.getElementById('currentEq');
  eqDiv.innerHTML = `$${eq}$`;
  MathJax.typesetPromise([eqDiv]);

  drawGrid();
  drawLine(targetA, targetB, "blue", 3); // 목표
  drawLine(userA, userB, "red", 5);     // 유저
}

// 새 문제 생성
function nextProblem() {
  isProcessing = false;
  resultreset();
  
  // 랜덤 목표 생성 (기울기 0 제외)
  targetA = 0;
  while(targetA === 0) {
    targetA = (Math.floor(Math.random() * 17) - 8) / 2; // -4 ~ 4 (0.5 단위)
  }
  
  targetB = Math.floor(Math.random() * 9) - 4; // -4 ~ 4
  
  // 목표 수식 표시
  let eq = formatEquation(targetA, targetB);
  const targetDiv = document.getElementById('targetEq');
  targetDiv.innerHTML = `$${eq}$`;
  MathJax.typesetPromise([targetDiv]);
  
  // 사용자 초기값
  let initA = 1; 
  let initB = 0;
  if (initA === targetA && initB === targetB) initB = targetB + 1;

  document.getElementById('sliderA').value = initA;
  document.getElementById('sliderB').value = initB;
  
  updateGraph();
}

// 결과 초기화
function resultreset() {
    const r1 = document.getElementById("result1");
    r1.textContent = "정답여부";
    r1.style.backgroundColor = "white";
    r1.style.color = "black";
}

// 정답 확인
function checkMatch() {
  if(isProcessing) return;
  
  let userA = parseFloat(document.getElementById('sliderA').value);
  let userB = parseFloat(document.getElementById('sliderB').value);
  
  const r1 = document.getElementById("result1");
  const r2 = document.getElementById("result2");
  const r3 = document.getElementById("result3");

  if(userA === targetA && userB === targetB) {
    isProcessing = true;
    wincount++;
    r1.textContent = "정답입니다.";
    r1.style.backgroundColor = "green";
    r1.style.color = "white";
    r2.textContent = wincount + "번 정답입니다.";
    
    setTimeout(() => {
      nextProblem();
    }, 1000);
  } else {
    losecount++;
    r1.textContent = "틀렸습니다.";
    r1.style.backgroundColor = "red";
    r1.style.color = "white";
    r3.textContent = losecount + "번 틀렸습니다.";
    
    setTimeout(() => {
      resultreset();
    }, 1500);
  }
}

window.onload = nextProblem;
</script>
</body>
</html>